<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.2543ff947a193d7f33b1.css">@import url(https://fonts.googleapis.com/css?family=Inconsolata&display=swap);@import url(https://fonts.googleapis.com/css?family=Source+Sans+Pro&display=swap);</style><meta name="generator" content="Gatsby 2.24.85"/><title data-rh="true">ShapeSense | Vision Cortex</title><meta data-rh="true" name="description" content="Semantic Computer Vision"/><meta data-rh="true" property="og:title" content="ShapeSense"/><meta data-rh="true" property="og:description" content="Semantic Computer Vision"/><meta data-rh="true" property="og:type" content="website"/><meta data-rh="true" name="twitter:card" content="summary"/><meta data-rh="true" name="twitter:title" content="ShapeSense"/><meta data-rh="true" name="twitter:description" content="Semantic Computer Vision"/><link as="script" rel="preload" href="/webpack-runtime-ed686ae4d7040c59007b.js"/><link as="script" rel="preload" href="/styles-83801f3b4dd3459a4027.js"/><link as="script" rel="preload" href="/framework-34df0b3f72b72d7c6b1a.js"/><link as="script" rel="preload" href="/app-c7673cccdcda4c07b220.js"/><link as="script" rel="preload" href="/798c9f31-55401554f16c5ec017b9.js"/><link as="script" rel="preload" href="/c5b55e2f8b53e5f5ce74c9de3c70a46d4d065a47-cc82b785e04af3879186.js"/><link as="script" rel="preload" href="/component---src-shapesense-mdx-a28963d66c7dc0995df0.js"/><link as="fetch" rel="preload" href="/page-data/shape-sense-docs/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/1635659820.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion-css="1ouyflx">.css-1ouyflx{font-family:'Source Sans Pro',sans-serif;font-size:20px;font-weight:400;line-height:1.5;color:var(--theme-ui-colors-text,#2D3747);background-color:var(--theme-ui-colors-background,#FFFFFF);}</style><div class="css-1ouyflx"><style data-emotion-css="jrjj6h">.css-jrjj6h > div{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;}</style><style data-emotion-css="1ubpee3">.css-1ubpee3{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.css-1ubpee3 > div{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;}</style><style data-emotion-css="hbri28">.css-hbri28{box-sizing:border-box;min-width:0;min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}.css-hbri28 > div{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;}</style><div data-testid="layout" class="css-hbri28"><style data-emotion-css="1xva7m0">body{margin:0;padding:0;}.icon-link{display:none;}.with-overlay{overflow:hidden;}</style><style data-emotion-css="zf0iqh">.css-zf0iqh{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;}</style><style data-emotion-css="1tjxv7i">.css-1tjxv7i{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;}</style><style data-emotion-css="238csb">.css-238csb{box-sizing:border-box;min-width:0;-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;}</style><main class="css-238csb"><style data-emotion-css="18wmtq">.css-18wmtq{background-color:var(--theme-ui-colors-header-bg,#F5F6F7);position:relative;z-index:1;border-bottom:1px solid var(--theme-ui-colors-border,#CED4DE);}</style><div data-testid="header" class="css-18wmtq"><style data-emotion-css="zankq9">.css-zankq9{display:none;position:absolute;top:calc(100% + 15px);left:30px;}@media screen and (max-width:57.5em){.css-zankq9{display:block;}}</style><style data-emotion-css="1s0wdqz">.css-1s0wdqz{box-sizing:border-box;min-width:0;display:none;position:absolute;top:calc(100% + 15px);left:30px;}@media screen and (max-width:57.5em){.css-1s0wdqz{display:block;}}</style><div class="css-1s0wdqz"><style data-emotion-css="4019lz">.css-4019lz{padding:0;outline:none;background:transparent;border:none;color:var(--theme-ui-colors-header-text,#2D3747);opacity:0.5;cursor:pointer;}.css-4019lz:hover{cursor:pointer;}</style><button class="css-4019lz"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button></div><style data-emotion-css="z6jak6">.css-z6jak6{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;padding-left:32px;padding-right:32px;position:relative;height:80px;}</style><div class="css-z6jak6"><style data-emotion-css="xenp3v">.css-xenp3v{-webkit-letter-spacing:-0.02em;-moz-letter-spacing:-0.02em;-ms-letter-spacing:-0.02em;letter-spacing:-0.02em;font-weight:600;font-size:24px;}</style><style data-emotion-css="1abzlu">.css-1abzlu{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-letter-spacing:-0.02em;-moz-letter-spacing:-0.02em;-ms-letter-spacing:-0.02em;letter-spacing:-0.02em;font-weight:600;font-size:24px;}</style><style data-emotion-css="ug0363">.css-ug0363{box-sizing:border-box;min-width:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-letter-spacing:-0.02em;-moz-letter-spacing:-0.02em;-ms-letter-spacing:-0.02em;letter-spacing:-0.02em;font-weight:600;font-size:24px;}</style><div data-testid="logo" class="css-ug0363"><style data-emotion-css="gyijir">.css-gyijir{font-weight:600;color:var(--theme-ui-colors-header-text,#2D3747);-webkit-text-decoration:none;text-decoration:none;}.css-gyijir:hover{color:var(--theme-ui-colors-primary,#0B5FFF);}</style><a style="height:48px" class="css-gyijir" href="/"><img style="height:100%" src="/public/visioncortex-logo.svg"/></a></div><style data-emotion-css="k008qs">.css-k008qs{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}</style><style data-emotion-css="80zs6q">.css-80zs6q{box-sizing:border-box;min-width:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}</style><div class="css-80zs6q"><style data-emotion-css="1is33jg">.css-1is33jg{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;outline:none;padding:12px;border:none;border-radius:9999px;background-color:var(--theme-ui-colors-header-button-bg,#0B5FFF);color:var(--theme-ui-colors-header-button-color,#FFFFFF);font-size:12px;font-weight:600;cursor:pointer;}</style><button aria-label="Switch to light mode" class="css-1is33jg"><svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></button></div></div></div><style data-emotion-css="1nfi0ai">.css-1nfi0ai{padding-top:0;padding-bottom:0;-webkit-flex:1;-ms-flex:1;flex:1;display:grid;grid-template-columns:250px minmax(0,1fr);min-height:100vh;}@media screen and (max-width:57.5em){.css-1nfi0ai{display:block;}}</style><div class="css-1nfi0ai"><style data-emotion-css="1tn7q1x">.css-1tn7q1x{z-index:999;position:fixed;top:81px;right:0;bottom:0;left:0;background:rgba(0,0,0,0.6);-webkit-transition:all .2s ease-out;transition:all .2s ease-out;visibility:hidden;opacity:0;}</style><style data-emotion-css="h4snl3">.css-h4snl3{box-sizing:border-box;min-width:0;z-index:999;position:fixed;top:81px;right:0;bottom:0;left:0;background:rgba(0,0,0,0.6);-webkit-transition:all .2s ease-out;transition:all .2s ease-out;visibility:hidden;opacity:0;}</style><div class="css-h4snl3"></div><style data-emotion-css="1ethd5x">.css-1ethd5x{padding-top:32px;padding-bottom:32px;padding-left:32px;padding-right:32px;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;position:-webkit-sticky;position:sticky;top:0;z-index:1;min-width:0;max-height:100vh;border-right:1px solid var(--theme-ui-colors-border,#CED4DE);overflow:auto;-webkit-overflow-scrolling:touch;background-color:var(--theme-ui-colors-sidebar-bg,#FFFFFF);}@media screen and (max-width:57.5em){.css-1ethd5x{z-index:9999;display:block;position:fixed;top:81px;left:0;bottom:0;width:256px;padding-left:32px;padding-right:32px;background-color:var(--theme-ui-colors-background,#FFFFFF);-webkit-transition:-webkit-transform .2s ease-out;-webkit-transition:transform .2s ease-out;transition:transform .2s ease-out;-webkit-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);}}</style><style data-emotion-css="1li9yso">.css-1li9yso{box-sizing:border-box;min-width:0;padding-top:32px;padding-bottom:32px;padding-left:32px;padding-right:32px;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;position:-webkit-sticky;position:sticky;top:0;z-index:1;min-width:0;max-height:100vh;border-right:1px solid var(--theme-ui-colors-border,#CED4DE);overflow:auto;-webkit-overflow-scrolling:touch;background-color:var(--theme-ui-colors-sidebar-bg,#FFFFFF);}@media screen and (max-width:57.5em){.css-1li9yso{z-index:9999;display:block;position:fixed;top:81px;left:0;bottom:0;width:256px;padding-left:32px;padding-right:32px;background-color:var(--theme-ui-colors-background,#FFFFFF);-webkit-transition:-webkit-transform .2s ease-out;-webkit-transition:transform .2s ease-out;transition:transform .2s ease-out;-webkit-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);}}</style><div data-testid="sidebar" class="css-1li9yso"><style data-emotion-css="lcm9hh">.css-lcm9hh{margin-bottom:16px;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}</style><div data-testid="nav-search" class="css-lcm9hh"><style data-emotion-css="1mo6uhh">.css-1mo6uhh{color:var(--theme-ui-colors-border,#CED4DE);margin-right:8px;}</style><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="css-1mo6uhh"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><style data-emotion-css="1bbueiu">.css-1bbueiu{outline:none;background:none;border:none;color:var(--theme-ui-colors-text,#2D3747);font-size:14px;}</style><input placeholder="Type to search..." value="" class="css-1bbueiu"/></div><style data-emotion-css="1rqvyud">.css-1rqvyud{margin-top:8px;margin-bottom:8px;display:block;color:var(--theme-ui-colors-sidebar-navGroup,#2D3747);-webkit-text-decoration:none;text-decoration:none;font-size:16px;}.css-1rqvyud.active{color:var(--theme-ui-colors-sidebar-navLinkActive,#0B5FFF);}</style><a class="css-1rqvyud" href="/">Vision Cortex</a><a class="css-1rqvyud" href="/symcode-docs">SymCode</a><a class="css-1rqvyud" href="/impression-docs">Impression</a><a class="css-1rqvyud" href="/vtracer-docs">VTracer</a></div><script async="" type="text/javascript">
      (function(c,l,a,r,i,t,y){
          c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
          t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
          y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
      })(window, document, "clarity", "script", "403biw7tra");
    </script><style data-emotion-css="1w3d2mg">.css-1w3d2mg{background-color:var(--theme-ui-colors-background,#FFFFFF);position:relative;max-width:1280px;padding-top:48px;padding-bottom:48px;padding-left:32px;padding-right:32px;padding:32px;}@media screen and (max-width:57.5em){.css-1w3d2mg{padding-top:48px;padding-bottom:32px;padding-left:32px;padding-right:32px;}}</style><style data-emotion-css="kjtkh5">.css-kjtkh5{width:100%;min-width:0;max-width:1280px;margin-left:auto;margin-right:auto;padding:32px;background-color:var(--theme-ui-colors-background,#FFFFFF);position:relative;max-width:1280px;padding-top:48px;padding-bottom:48px;padding-left:32px;padding-right:32px;padding:32px;}@media screen and (max-width:57.5em){.css-kjtkh5{padding-top:48px;padding-bottom:32px;padding-left:32px;padding-right:32px;}}</style><style data-emotion-css="1307vk3">.css-1307vk3{box-sizing:border-box;min-width:0;width:100%;min-width:0;max-width:1280px;margin-left:auto;margin-right:auto;padding:32px;background-color:var(--theme-ui-colors-background,#FFFFFF);position:relative;max-width:1280px;padding-top:48px;padding-bottom:48px;padding-left:32px;padding-right:32px;padding:32px;}@media screen and (max-width:57.5em){.css-1307vk3{padding-top:48px;padding-bottom:32px;padding-left:32px;padding-right:32px;}}</style><div data-testid="main-container" class="css-1307vk3"><style data-emotion-css="1vci3bl">.css-1vci3bl{padding:0;margin:0;margin-bottom:16px;font-size:48px;font-family:'Source Sans Pro',sans-serif;line-height:1.125;font-weight:700;}</style><h1 id="shapesense---shape-completion-by-curve-stitching" class="css-1vci3bl">ShapeSense - Shape Completion by Curve Stitching</h1><style data-emotion-css="1ftn47p">.css-1ftn47p{padding:0;margin:0;margin-bottom:16px;}</style><p class="css-1ftn47p">Researcher: <style data-emotion-css="1iv9jyz">.css-1iv9jyz{color:var(--theme-ui-colors-primary,#0B5FFF);-webkit-text-decoration:none;text-decoration:none;}.css-1iv9jyz:hover{color:secondary;-webkit-text-decoration:underline;text-decoration:underline;}</style><a href="//github.com/shpun817" class="css-1iv9jyz">Sanford Pun</a> | Supervisor: <a href="//github.com/tyt2y3" class="css-1iv9jyz">Chris Tsang</a> | Published: 2022-01-02</p><style data-emotion-css="2abk98">.css-2abk98{padding:0;margin:0;margin-bottom:16px;border:0;border-bottom:1px solid var(--theme-ui-colors-border,#CED4DE);margin-top:-1px;}</style><hr class="css-2abk98"/><p class="css-1ftn47p">Repository: <a href="https://github.com/visioncortex/ShapeSense" class="css-1iv9jyz">visioncortex/ShapeSense</a></p><p class="css-1ftn47p">This project aims at recovering (completing) the <style data-emotion-css="1vg6q84">.css-1vg6q84{font-weight:700;}</style><strong class="css-1vg6q84">structure</strong> of a shape after a portion of it is erased. In other words, given a shape with arbitrarily &quot;discontinued parts&quot;, assuming that we have <strong class="css-1vg6q84">no prior knowledge</strong> about the shape, how can we <strong class="css-1vg6q84">reasonably connect the endpoints</strong> at the discontinuities?</p><div><img alt="Hole showcase" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/hole_showcase.png"/><h4 style="text-align:center">A shape with a hole. There are 6 endpoints in this case.</h4></div><p class="css-1ftn47p">In the demo images shown throughout this documentation, the following coloring scheme is used: Black pixels denote the background. Red pixels denote the rasterized <em class="css-0">shape</em>. White pixels denote the <em class="css-0">hole</em>. The (imaginary) intersection of the shape and the hole is the aforementioned &quot;discontinued parts&quot;, which is what we try to recover.</p><div><img alt="Recovered shape showcase." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/recovered_shape.png"/><h4 style="text-align:center">An example of completed shape.</h4></div><p class="css-1ftn47p">Blue pixels will be used to denote the outline of the recovered parts of the shape.</p><p class="css-1ftn47p">The whole process of shape completion involves intrapolating the missing outline and then filling the pixels in the hole with appropriate colors.</p><h2 id="simple-shape-completion"><style data-emotion-css="1r0pe6c">.css-1r0pe6c{color:inherit;-webkit-text-decoration:none;text-decoration:none;}.css-1r0pe6c:hover{-webkit-text-decoration:underline;text-decoration:underline;}</style><a href="#simple-shape-completion" class="css-1r0pe6c">Simple Shape Completion</a></h2><p class="css-1ftn47p">Let&#x27;s begin the experiment with simple shapes, like an ellipse.</p><div><img alt="An ellipse ground truth and another one with a hole." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/ellipse_groundtruth_and_with_hole.png"/><h4 style="text-align:center">The first image is the ground truth (for reference only). The second image is the input to the ShapeCompletion pipeline.</h4></div><h3 id="path-preprocessing"><a href="#path-preprocessing" class="css-1r0pe6c">Path Preprocessing</a></h3><p class="css-1ftn47p">The first stage of the pipeline is to obtain and process the paths (curves) representing the existing outline of the shape.</p><p class="css-1ftn47p"><a href="//github.com/visioncortex/visioncortex" class="css-1iv9jyz">Vision Cortex&#x27;s core library</a> provides the necessary utilities to extract raw paths from an image.</p><div><img alt="Path segments after preprocessing." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/ellipse_preprocessed_path.png"/><h4 style="text-align:center">Yellow pixels denote the identified outline of the shape after simplification.</h4></div><h3 id="tail-tangent-approximation"><a href="#tail-tangent-approximation" class="css-1r0pe6c">Tail Tangent Approximation</a></h3><p class="css-1ftn47p">The next step is to (divide, if needed, and) extract the two curves from the two endpoints; smoothing is performed to better approximate the tangents near the endpoints (<em class="css-0">tails</em> of the whole curve). After this step, we will obtain two tangents (2-D direction vectors), one at each tail. We will call these tangents <em class="css-0">tail tangents</em>.</p><div><img alt="Tail tangent approximation results." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/tail_tangent_approx.png"/><h4 style="text-align:center">The naive approach is to simply take A as the tail tangent, but better (more practical/useful) approximations may be obtained by taking more subsequent segments into account (e.g. B, C, D).</h4></div><p class="css-1ftn47p">A number of factors determine the accuracy and robustness of tail tangent approximation. Our implementation supports configurations like how many points to consider from the tails, how long should the segments being considered accumulate to, and how the weights for each segment should change towards the tails.</p><h3 id="intrapolation"><a href="#intrapolation" class="css-1r0pe6c">Intrapolation</a></h3><style data-emotion-css="16r6o5s">.css-16r6o5s{padding:0;margin:0;margin-bottom:32px;margin-left:0;margin-right:0;margin-top:32px;padding-top:16px;padding-bottom:16px;padding-left:32px;padding-right:32px;background-color:var(--theme-ui-colors-blockquote-bg,#F5F6F7);border-left:5px solid var(--theme-ui-colors-blockquote-border,#CED4DE);color:var(--theme-ui-colors-blockquote-color,#67788a);font-style:italic;}.css-16r6o5s > p{margin:0;}</style><blockquote class="css-16r6o5s"><p class="css-1ftn47p"><strong class="css-1vg6q84">Why &quot;<b class="css-1vg6q84">Intra</b>polation&quot;?</strong><br/>
If we considered the existing outline of the shape as separate curves at each endpoint, we would be doing <i class="css-0"><b class="css-1vg6q84">inter</b>polation</i> <b class="css-1vg6q84">between</b> curves. However, in this project, we are focusing on curves (existing + missing) that form an outline of a single shape, so we argue that we are doing <i class="css-0"><b class="css-1vg6q84">intra</b>polation</i> <b class="css-1vg6q84">within</b> a curve.</p></blockquote><p class="css-1ftn47p">With the two endpoints and their corresponding tail tangents, we can calculate for the missing part in different scenarios. The type of curves used in this project is cubic <a href="//en.wikipedia.org/wiki/B%C3%A9zier_curve" class="css-1iv9jyz">Bézier curves</a>. To specify such a curve, four points are required. An important property to note about this type of curves is that <em class="css-0">the curve constructed is always fully contained in the quadrilateral defined by the four points</em>.</p><p class="css-1ftn47p">The first scenario is when the two tail tangents point to the same side with respect to the line connecting the two endpoints (we call this line the <em class="css-0">base</em>).</p><div><img alt="Intrapolation when both tail tangents point to the same side" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/intrapolate_same_side.png"/><h4 style="text-align:center">Both tail tangents at A and B point to the same side of the red, dashed line (the base).</h4></div><div class="css-0"><p class="css-1ftn47p">To construct the curve between A and B, we need to identify two <em class="css-0">control points</em> (C<sub>A</sub> and C<sub>B</sub>) between them. In our approach, we started with what we think is intuitive and made tweaks to resolve some issues in practice; this is what we end up with:</p></div><br/><div class="css-0"><p class="css-1ftn47p">First, find the intersection of the two lines starting at A and B along the corresponding tail tangent. The mid-points between A/B and the intersection are then set to be C<sub>A</sub> and C<sub>B</sub>. If the intersection is too far away (i.e. the two lines are close to, if not exactly, parallel), we simply use a point on each line as the control points (e.g. translate A/B along their tail tangent by a factor of base length). Either way, if either C<sub>A</sub> or C<sub>B</sub> end up lying outside the hole region, we <em class="css-0">retract</em> it by pushing it towards the endpoint, until it reaches the hole region.</p></div><blockquote class="css-16r6o5s"><p class="css-1ftn47p"><strong class="css-1vg6q84">What if the intersection was in the other direction?</strong><br/>
<div><img alt="Tail tangents bent outwards; pulled back to be perpendicular to the base." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/intrapolation_bent_outwards.png"/><h4 style="text-align:center">If the line originating from A and B intersect in the negative direction (as shown above), we simply correct them by bending them inwards to be perpendicular with the base.</h4></div></p></blockquote><p class="css-1ftn47p">Another scenario is when the two tail tangents point to different sides of the base, as below.</p><div><img alt="Intrapolation with tail tangents pointing to different sides of the base" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/intrapolate_diff_sides.png"/><h4 style="text-align:center">A simple dot product operation can be used to detect such a scenario.</h4></div><p class="css-1ftn47p">In this case, any intersections detected are meaningless because they must lie outside the hole region. Instead, we divide the curve into two halves and intrapolate two subcurves from each endpoint to the mid-point of the base as shown above.</p><p class="css-1ftn47p">The last possible scenario is trivial to handle: when the lines are coincident, simply connect the endpoints with a straight line.</p><div><img alt="Intrapolation becomes connecting endpoints with a straight line in coincidence" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/intrapolate_coincidence.png"/><h4 style="text-align:center"></h4></div><p class="css-1ftn47p">The case of our simple ellipse falls into the first scenario. The intrapolated outline is shown as follows:</p><div><img alt="Full ellipse outline after intrapolation." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/ellipse_intrapolated.png"/><h4 style="text-align:center"></h4></div><h3 id="color-filling"><a href="#color-filling" class="css-1r0pe6c">Color filling</a></h3><p class="css-1ftn47p">To fill the hole with appropriate colors, we define three element types: <em class="css-0">Blank</em>, <em class="css-0">Structure</em>, and <em class="css-0">Texture</em>. Note that in this project, it is restricted that only one shape is processed at once, and actual texture recovery is not performed - we&#x27;re only interested in knowing which parts of the hole are Blank, Structure, or Texture.</p><style data-emotion-css="134anpw">.css-134anpw{padding:0;margin:0;margin-bottom:32px;border-collapse:separate;width:100%;margin-top:32px;border-spacing:0;}.css-134anpw th,.css-134anpw td{text-align:left;padding-top:4px;padding-bottom:4px;padding-right:4px;padding-left:0;border-color:var(--theme-ui-colors-muted,#67788a);border-bottom-style:solid;}</style><table class="css-134anpw"><thead><tr class="css-0"><style data-emotion-css="hafajd">.css-hafajd{text-align:left;border-bottom:1px solid;padding-left:8px;padding-right:8px;padding-top:4px;padding-bottom:4px;vertical-align:bottom;border-bottom-width:2px;}.css-hafajd:first-child{padding-left:0;}.css-hafajd:last-child{padding-right:0;}</style><th class="css-hafajd">Element</th><th class="css-hafajd">Description</th></tr></thead><tbody><tr class="css-0"><style data-emotion-css="11a86gi">.css-11a86gi{text-align:left;border-bottom:1px solid;padding-left:8px;padding-right:8px;padding-top:4px;padding-bottom:4px;margin-top:-1px;vertical-align:top;border-bottom-width:1px;}.css-11a86gi:first-child{padding-left:0;}.css-11a86gi:last-child{padding-right:0;}</style><td class="css-11a86gi">Blank</td><td class="css-11a86gi">Background pixels. (Black in our demo)</td></tr><tr class="css-0"><td class="css-11a86gi">Structure</td><td class="css-11a86gi">Outline of the shape; The intrapolated curve(s) obtained above is rasterized and drawn onto the hole. (Blue in our demo)</td></tr><tr class="css-0"><td class="css-11a86gi">Texture</td><td class="css-11a86gi">Solid part of the shape; To be filled in this section. (Red in our demo)</td></tr></tbody></table><p class="css-1ftn47p">The Structure elements divide the hole into several subregions. Each of these subregions contains wholly either Blank or Texture elements.</p><div><img alt="Hole of ellipse divided into two subregions" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/filling_subregions.png"/><h4 style="text-align:center"></h4></div><p class="css-1ftn47p">In our example, the hole is divided by the intrapolated curve into two subregions. In order to guess whether to fill the subregions with Blank or Texture elements, we check if the number of Blank elements outside the hole boundary exceeds a certain tolerance.</p><p class="css-1ftn47p">For the bottom subregion, the pixels right outside the bottom boundary are (almost) all red (Texture), therefore this subregion is classified as Texture and filled with Texture elements.</p><p class="css-1ftn47p">For the top subregion, the pixels outside the left, top, and right sides of the boundary are considered. All of those pixels are background (Blank), so this subregion is classified as Blank.</p><p class="css-1ftn47p">After filling, the shape of the ellipse is completed, as follows:</p><div><img alt="Complete ellipse" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/ellipse_complete.png"/><h4 style="text-align:center"></h4></div><p class="css-1ftn47p">If we move the hole around, shape completion yields the following results:</p><div><img alt="Complete ellipses with different holes" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/simple/ellipse_diff_holes.png"/><h4 style="text-align:center"></h4></div><h2 id="complex-shape-completion"><a href="#complex-shape-completion" class="css-1r0pe6c">Complex Shape Completion</a></h2><p class="css-1ftn47p">The process of shape completion shown above has been rather straightforward because there is a strong assumption - the hole cuts the shape at exactly 2 endpoints only. Consider the following case:</p><div><img alt="Ellipse with a long hole cutting its boundary at 4 endpoints" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/complex/ellipse_hole_across.png"/><h4 style="text-align:center">At a glance, we can tell how the endpoints should be grouped - A with B, and C with D, but how can we model the problem to match the endpoints such that the result of color filling always makes sense?</h4></div><h3 id="endpoint-matching"><a href="#endpoint-matching" class="css-1r0pe6c">Endpoint Matching</a></h3><h4 id="failed-attempt-local-proximity"><a href="#failed-attempt-local-proximity" class="css-1r0pe6c">Failed attempt: Local Proximity</a></h4><p class="css-1ftn47p">An intuitive approach might be by endpoint proximity in a greedy manner. If we simply connect each endpoint to its nearest neighbor, the correct matching is found for the above case. However, this approach ceases to work for the following case:</p><div><img alt="Tall hole over ellipse." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/complex/ellipse_local_proximity_counterexample.png"/><h4 style="text-align:center">The correct matching seems to be A with B and C with D, but the top two endpoints are the closest.</h4></div><h4 id="avoiding-intersections"><a href="#avoiding-intersections" class="css-1r0pe6c">Avoiding Intersections</a></h4><p class="css-1ftn47p">Problematic matchings are the ones that lead to intersecting curves. If intersection occurs, the resulting shape deforms and there may be subregions that are surrounded by others, leading to problems in color filling. Therefore, the key of endpoint matching lies in <strong class="css-1vg6q84">avoiding intersections</strong>.</p><p class="css-1ftn47p">Before intrapolation, some intersecting curves can already be identified by looking at endpoint connections that intersect.</p><p class="css-1ftn47p">Imagine we have 4 endpoints A, B, C, and D. If the line segment AB intersects with CD, then the curve intrapolated from A to B must intersect with that from C to D.</p><div><img alt="Line intersection among endpoints implies intersection of intrapolated curves" style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/complex/line_intersect_implies_curve_intersect.png"/><h4 style="text-align:center"></h4></div><p class="css-1ftn47p">Therefore, the first step to avoiding intersecting curves is to filter out matchings that contain intersecting lines.</p><p class="css-1ftn47p">This <a href="//prase.cz/kalva/putnam/psoln/psol794.html" class="css-1iv9jyz">webpage</a> shows that minimizing the total length of endpoint connections is equivalent to finding a matching with no intersecting connections. Hence the problem is reduced to a <a href="//core.ac.uk/download/pdf/82212931.pdf" class="css-1iv9jyz">Euclidean Bipartite Matching Problem</a>, i.e. optimizing the global weights over matchings. The <a href="//en.wikipedia.org/wiki/Hungarian_algorithm" class="css-1iv9jyz">Hungarian algorithm</a> is used to solve such a problem.</p><p class="css-1ftn47p">The rest of the intersecting curves have to be caught and filtered out after intrapolation has taken place. Bézier curve intersection can be detected by a recursive method called <a href="//en.wikipedia.org/wiki/De_Casteljau%27s_algorithm" class="css-1iv9jyz">De Casteljau&#x27;s (Bézier Clipping) algorithm</a>, which is implemented in <a href="//crates.io/crates/flo_curves" class="css-1iv9jyz">flo_curves</a>, the Bézier curve library we use.</p><h2 id="robustness"><a href="#robustness" class="css-1r0pe6c">Robustness</a></h2><p class="css-1ftn47p">Throughout the process of development, we encountered many edge cases where the pipeline would break down when faced with certain geometrical configurations. For example, an endpoint detected at the corner of the hole may or may not be useful, because it may be an edge entering the hole at a corner, or it may just be the hole touching an edge with its corner.</p><p class="css-1ftn47p">As much as we hope to correctly handle every single situation (if it&#x27;s possible in the first place), we figured, from an engineering perspective, that we want an effective way to secure maximum overall robustness with a reasonable amount of effort.</p><p class="css-1ftn47p">From experimentation, we observed that most of the pain-inducing geometrical configurations were deformed once we move the hole by just 1 pixel. Therefore, we decided that once the pipeline breaks down, it should try to <strong class="css-1vg6q84">recover by expanding the hole by 1 pixel in each direction</strong>. If it successfully produces something in one of these attempts, that result is used.</p><hr class="css-2abk98"/><div><img alt="Animated Demo." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/animated_demo.gif"/><h4 style="text-align:center"></h4></div><p class="css-1ftn47p">As shown above, the performance of our implementation is stable for the most part. Occasionally, the pipeline (arguably) incorrectly handles the cases when tail tangents are (nearly) coincident to the hole boundaries.</p><div><img alt="Arguably incorrect case." style="display:block;margin-left:auto;margin-right:auto;max-width:100%" src="/public/shape-sense/incorrect.png"/><h4 style="text-align:center"></h4></div><h2 id="discussion"><a href="#discussion" class="css-1r0pe6c">Discussion</a></h2><p class="css-1ftn47p">The direct application of this algorithm is symbolic recognition, where a part of a symbol might be obscured artificially or accidentally.</p><p class="css-1ftn47p">It can also be used in image repairing provided we are able to construct a high level shape structures of a natural photograph.</p><p class="css-1ftn47p">As only the local information around the unknown region is used, the above shape reconstruction operation is entropy neutral, where no new information is introduced and no priori knowledge is assumed.</p><p class="css-1ftn47p">This is a key factor, consider that if we have priori knowledge or simply are making wild guesses to what the original symbol might be, it completely changes the problem or actually defies the reason of shape completion.</p><p class="css-1ftn47p">Under the symbolic recognition framework we propose (will be detailed in another article), recognition is a macroscopic statistical measurement that would greatly benefit from missing pieces filled in.</p></div></div></main></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/shape-sense-docs";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-12b334af0ca7496d7f19.js"],"app":["/app-c7673cccdcda4c07b220.js"],"component---src-impression-mdx":["/component---src-impression-mdx-7396b5c988c84a072add.js"],"component---src-index-mdx":["/component---src-index-mdx-0934d2e2f2b0fd64a218.js"],"component---src-pages-404-js":["/component---src-pages-404-js-9c134c3c1761f19419a4.js"],"component---src-reversi-mdx":["/component---src-reversi-mdx-891984c4e973d2621598.js"],"component---src-shapesense-mdx":["/component---src-shapesense-mdx-a28963d66c7dc0995df0.js"],"component---src-symcode-mdx":["/component---src-symcode-mdx-4c86476283db67665ee4.js"],"component---src-vtracer-mdx":["/component---src-vtracer-mdx-0593babbb68bc0de1d9d.js"]};/*]]>*/</script><script src="/polyfill-12b334af0ca7496d7f19.js" nomodule=""></script><script src="/component---src-shapesense-mdx-a28963d66c7dc0995df0.js" async=""></script><script src="/c5b55e2f8b53e5f5ce74c9de3c70a46d4d065a47-cc82b785e04af3879186.js" async=""></script><script src="/798c9f31-55401554f16c5ec017b9.js" async=""></script><script src="/app-c7673cccdcda4c07b220.js" async=""></script><script src="/framework-34df0b3f72b72d7c6b1a.js" async=""></script><script src="/styles-83801f3b4dd3459a4027.js" async=""></script><script src="/webpack-runtime-ed686ae4d7040c59007b.js" async=""></script></body></html>